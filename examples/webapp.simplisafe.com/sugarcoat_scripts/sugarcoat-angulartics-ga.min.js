{
    const $___mock_a5bc79bcf07d3b62 = {};
    (exports => {
        'use strict';
        const xhrUnsent = 0;
        const xhrOpened = 1;
        const xhrHeadersReceived = 2;
        const xhrLoading = 3;
        const xhrDone = 4;
        const xhrDeferredHandleSymbol = Symbol('deferredHandle');
        const xhrOnLoadStartSymbol = Symbol('onloadstart');
        const xhrOnProgressSymbol = Symbol('onprogress');
        const xhrOnAbortSymbol = Symbol('onabort');
        const xhrOnErrorSymbol = Symbol('onerror');
        const xhrOnLoadSymbol = Symbol('onload');
        const xhrOnTimeoutSymbol = Symbol('ontimeout');
        const xhrOnLoadEndSymbol = Symbol('onloadend');
        const xhrOnReadyStateChangeSymbol = Symbol('onreadystatechange');
        const xhrReadyStateSymbol = Symbol('readyState');
        const xhrTimeoutSymbol = Symbol('timeout');
        const xhrWithCredentialsSymbol = Symbol('withCredentials');
        const xhrUploadSymbol = Symbol('upload');
        const xhrResponseTypeSymbol = Symbol('responseType');
        const defineEvent = (obj, symbol) => {
            const type = symbol.description.substring(2);
            Object.defineProperty(obj, symbol, {
                configurable: false,
                enumerable: false,
                value: null,
                writable: true
            });
            obj.addEventListener(type, function (event) {
                const handler = this[symbol];
                if (handler) {
                    handler.call(this, event);
                }
            });
        };
        const changeReadyState = (xhr, readyState) => {
            xhr[xhrReadyStateSymbol] = readyState;
            xhr.dispatchEvent(new Event('readystatechange'));
        };
        let isSealed = true;
        class XMLHttpRequestEventTarget extends EventTarget {
            constructor() {
                super();
                if (!(this instanceof XMLHttpRequest) && !(this instanceof XMLHttpRequestUpload)) {
                    throw new TypeError('Illegal constructor');
                }
                defineEvent(this, xhrOnLoadStartSymbol);
                defineEvent(this, xhrOnProgressSymbol);
                defineEvent(this, xhrOnAbortSymbol);
                defineEvent(this, xhrOnErrorSymbol);
                defineEvent(this, xhrOnLoadSymbol);
                defineEvent(this, xhrOnTimeoutSymbol);
                defineEvent(this, xhrOnLoadEndSymbol);
            }
            get onloadstart() {
                return this[xhrOnLoadStartSymbol];
            }
            set onloadstart(value) {
                this[xhrOnLoadStartSymbol] = value;
            }
            get onprogress() {
                return this[xhrOnProgressSymbol];
            }
            set onprogress(value) {
                this[xhrOnProgressSymbol] = value;
            }
            get onabort() {
                return this[xhrOnAbortSymbol];
            }
            set onabort(value) {
                this[xhrOnAbortSymbol] = value;
            }
            get onerror() {
                return this[xhrOnErrorSymbol];
            }
            set onerror(value) {
                this[xhrOnErrorSymbol] = value;
            }
            get ontimeout() {
                return this[xhrOnTimeoutSymbol];
            }
            set ontimeout(value) {
                this[xhrOnTimeoutSymbol] = value;
            }
            get onloadend() {
                return this[xhrOnLoadEndSymbol];
            }
            set onloadend(value) {
                this[xhrOnLoadEndSymbol] = value;
            }
        }
        exports.XMLHttpRequestEventTarget = {
            configurable: true,
            enumerable: true,
            value: XMLHttpRequestEventTarget,
            writable: true
        };
        class XMLHttpRequestUpload extends XMLHttpRequestEventTarget {
            constructor() {
                if (isSealed) {
                    throw new TypeError('Illegal constructor');
                }
                super();
            }
        }
        exports.XMLHttpRequestUpload = {
            configurable: true,
            enumerable: true,
            value: XMLHttpRequestUpload,
            writable: true
        };
        class XMLHttpRequest extends XMLHttpRequestEventTarget {
            constructor() {
                super();
                isSealed = false;
                const xhrUpload = new XMLHttpRequestUpload();
                isSealed = true;
                Object.defineProperty(this, xhrDeferredHandleSymbol, {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: true
                });
                defineEvent(this, xhrOnReadyStateChangeSymbol);
                Object.defineProperty(this, xhrReadyStateSymbol, {
                    configurable: false,
                    enumerable: false,
                    value: xhrUnsent,
                    writable: true
                });
                Object.defineProperty(this, xhrTimeoutSymbol, {
                    configurable: false,
                    enumerable: false,
                    value: 0,
                    writable: true
                });
                Object.defineProperty(this, xhrWithCredentialsSymbol, {
                    configurable: false,
                    enumerable: false,
                    value: false,
                    writable: true
                });
                Object.defineProperty(this, xhrUploadSymbol, {
                    configurable: false,
                    enumerable: false,
                    value: xhrUpload,
                    writable: false
                });
                Object.defineProperty(this, xhrResponseTypeSymbol, {
                    configurable: false,
                    enumerable: false,
                    value: '',
                    writable: true
                });
            }
            get onreadystatechange() {
                return this[xhrOnReadyStateChangeSymbol];
            }
            set onreadystatechange(value) {
                this[xhrOnReadyStateChangeSymbol] = value;
            }
            get readyState() {
                return this[xhrReadyStateSymbol];
            }
            open(method, url) {
                switch (this[xhrReadyStateSymbol]) {
                case xhrUnsent:
                case xhrDone: {
                        changeReadyState(this, xhrOpened);
                        break;
                    }
                }
            }
            setRequestHeader(name, value) {
            }
            setTrustToken(trustToken) {
            }
            get timeout() {
                return this[xhrTimeoutSymbol];
            }
            set timeout(value) {
                this[xhrTimeoutSymbol] = value;
            }
            get withCredentials() {
                return this[xhrWithCredentialsSymbol];
            }
            set withCredentials(value) {
                switch (this[xhrReadyStateSymbol]) {
                case xhrUnsent:
                case xhrOpened: {
                        break;
                    }
                default: {
                        throw new DOMException('Failed to set the \'withCredentials\' property on \'XMLHttpRequest\': The value may only be set if the object\'s state is UNSENT or OPENED.');
                    }
                }
                this[xhrWithCredentialsSymbol] = !!value;
            }
            get upload() {
                return this[xhrUploadSymbol];
            }
            send() {
                if (this[xhrReadyStateSymbol] === xhrOpened && this[xhrDeferredHandleSymbol] === null) {
                    this[xhrDeferredHandleSymbol] = setTimeout(() => {
                        this[xhrDeferredHandleSymbol] = null;
                        changeReadyState(this, xhrDone);
                        this.dispatchEvent(new ProgressEvent('error'));
                        this.dispatchEvent(new ProgressEvent('loadend'));
                    }, 0);
                } else {
                    throw new DOMException('Failed to execute \'send\' on \'XMLHttpRequest\': The object\'s state must be OPENED.');
                }
            }
            abort() {
                if (this[xhrReadyStateSymbol] === xhrOpened && this[xhrDeferredHandleSymbol] !== null) {
                    clearTimeout(this[xhrDeferredHandleSymbol]);
                    this[xhrDeferredHandleSymbol] = null;
                    changeReadyState(this, xhrUnsent);
                    this.dispatchEvent(new ProgressEvent('abort'));
                    this.dispatchEvent(new ProgressEvent('loadend'));
                }
            }
            get responseURL() {
                return '';
            }
            get status() {
                return 0;
            }
            get statusText() {
                return '';
            }
            getResponseHeader(name) {
                return null;
            }
            overrideMimeType(mime) {
            }
            get responseType() {
                return this[xhrResponseTypeSymbol];
            }
            set responseType(value) {
                switch (this[xhrReadyStateSymbol]) {
                case xhrDone: {
                        throw new DOMException('Failed to set the \'responseType\' property on \'XMLHttpRequest\': The response type cannot be set if the object\'s state is LOADING or DONE.');
                    }
                }
                switch (value) {
                case '':
                case 'arraybuffer':
                case 'blob':
                case 'document':
                case 'json':
                case 'text': {
                        this[xhrResponseTypeSymbol] = value;
                        break;
                    }
                }
            }
            get response() {
                const responseType = this[xhrResponseTypeSymbol];
                return responseType === '' || responseType === 'text' ? '' : null;
            }
            get responseText() {
                const responseType = this[xhrResponseTypeSymbol];
                if (responseType === '' || responseType === 'text') {
                    return '';
                } else {
                    throw new DOMException('Failed to read the \'responseText\' property from \'XMLHttpRequest\': The value is only accessible if the object\'s \'responseType\' is \'\' or \'text\' (was \'arraybuffer\').');
                }
            }
            get responseXML() {
                return null;
            }
        }
        Object.defineProperty(XMLHttpRequest, 'UNSENT', {
            configurable: false,
            enumerable: true,
            value: xhrUnsent
        });
        Object.defineProperty(XMLHttpRequest, 'OPENED', {
            configurable: false,
            enumerable: true,
            value: xhrOpened
        });
        Object.defineProperty(XMLHttpRequest, 'HEADERS_RECEIVED', {
            configurable: false,
            enumerable: true,
            value: xhrHeadersReceived
        });
        Object.defineProperty(XMLHttpRequest, 'LOADING', {
            configurable: false,
            enumerable: true,
            value: xhrLoading
        });
        Object.defineProperty(XMLHttpRequest, 'DONE', {
            configurable: false,
            enumerable: true,
            value: xhrDone
        });
        exports.XMLHttpRequest = {
            configurable: true,
            enumerable: true,
            value: XMLHttpRequest,
            writable: true
        };
    })($___mock_a5bc79bcf07d3b62);
    (function () {
        !function (window, angular, undefined) {
            'use strict';
            angular.module('angulartics.google.analytics', ['angulartics']).config([
                '$analyticsProvider',
                function ($analyticsProvider) {
                    function detectUniversalAnalytics() {
                        var gaNamespace = window.GoogleAnalyticsObject;
                        return gaNamespace && window[gaNamespace];
                    }
                    function detectClassicAnalytics() {
                        return !angular.isUndefined(window._gaq);
                    }
                    function dimensionsAndMetrics(properties) {
                        var key, customData = {};
                        for (key in properties)
                            key.indexOf('dimension') && key.indexOf('metric') || (customData[key] = properties[key]);
                        return customData;
                    }
                    $analyticsProvider.settings.pageTracking.trackRelativePath = !0, $analyticsProvider.settings.ga = {
                        additionalAccountNames: undefined,
                        additionalAccountHitTypes: {
                            pageview: !0,
                            event: !0,
                            exception: !1,
                            ecommerce: !1,
                            userTiming: !1,
                            setUserProperties: !1,
                            userId: !1
                        },
                        disableEventTracking: null,
                        disablePageTracking: null,
                        userId: null,
                        enhancedEcommerce: !1
                    }, $analyticsProvider.registerPageTrack(function (path, properties) {
                        properties = properties || {}, $analyticsProvider.settings.ga.disablePageTracking || dispatchToGa('pageview', 'send', angular.extend(dimensionsAndMetrics(properties), {
                            hitType: 'pageview',
                            page: path
                        }));
                    }), $analyticsProvider.registerEventTrack(function (action, properties) {
                        if (!$analyticsProvider.settings.ga.disableEventTracking) {
                            if (!action && action + '' != '0')
                                return console.log('Missing required argument action');
                            if (properties = properties || {}, properties.category = properties.category || 'Event', properties.value) {
                                var parsed = parseInt(properties.value, 10);
                                properties.value = isNaN(parsed) ? 0 : parsed;
                            }
                            angular.isFunction(properties.hitCallback) || (properties.hitCallback = null), properties.nonInteraction = properties.nonInteraction || properties.noninteraction, dispatchToGa('event', 'send', angular.extend(dimensionsAndMetrics(properties), {
                                hitType: 'event',
                                eventCategory: properties.category,
                                eventAction: action,
                                eventLabel: properties.label,
                                eventValue: properties.value,
                                nonInteraction: properties.nonInteraction,
                                page: properties.page || window.location.hash.substring(1) || window.location.pathname,
                                hitCallback: properties.hitCallback
                            }));
                        }
                    }), $analyticsProvider.registerExceptionTrack(function (error, cause) {
                        dispatchToGa('exception', 'send', {
                            hitType: 'event',
                            eventCategory: 'Exceptions',
                            eventAction: error.toString(),
                            eventLabel: error.stack,
                            nonInteraction: !0,
                            page: window.location.hash.substring(1) || window.location.pathname,
                            isException: !0
                        });
                    }), $analyticsProvider.registerSetUsername(function (userId) {
                        $analyticsProvider.settings.ga.userId = userId;
                    }), $analyticsProvider.registerSetUserProperties(function (properties) {
                        properties && dispatchToGa('setUserProperties', 'set', dimensionsAndMetrics(properties));
                    }), $analyticsProvider.registerUserTimings(function (properties) {
                        return !angular.isObject(properties) || angular.isArray(properties) ? console.log('Required argument properties is missing or not an object') : (angular.forEach([
                            'timingCategory',
                            'timingVar',
                            'timingValue'
                        ], function (prop) {
                            if (angular.isUndefined(properties[prop]))
                                return console.log('Argument properties missing required property ' + prop);
                        }), void dispatchToGa('userTiming', 'send', {
                            hitType: 'timing',
                            timingCategory: properties.timingCategory,
                            timingVar: properties.timingVar,
                            timingValue: properties.timingValue,
                            timingLabel: properties.timingLabel,
                            optSampleRate: properties.optSampleRate,
                            page: properties.page || window.location.hash.substring(1) || window.location.pathname
                        }));
                    }), $analyticsProvider.registerTransactionTrack(function (transaction) {
                        var product, i;
                        if (dispatchToGa('ecommerce', 'require', 'ecommerce'), dispatchToGa('ecommerce', 'ecommerce:addTransaction', transaction), transaction.products)
                            for (i = 0; i < transaction.products.length; i++)
                                product = transaction.products[i], product.sku = product.id, product.id = transaction.id, dispatchToGa('ecommerce', 'ecommerce:addItem', transaction.products[i]);
                        transaction.currencyCode && dispatchToGa('ecommerce', '_set', transaction.currencyCode), dispatchToGa('ecommerce', 'ecommerce:send', dimensionsAndMetrics(transaction));
                    });
                    var dispatchToGa = function () {
                        function dispatchToUniversal_(command, fieldsObj, shouldCopyHit) {
                            const $___old_22dc4d56b12a305e = {}.constructor.getOwnPropertyDescriptor(window, 'XMLHttpRequest'), $___old_abf21b8e0a8354b3 = {}.constructor.getOwnPropertyDescriptor(window, 'XMLHttpRequest');
                            try {
                                if ($___old_22dc4d56b12a305e)
                                    ({}.constructor.defineProperty(window, 'XMLHttpRequest', $___mock_a5bc79bcf07d3b62.XMLHttpRequest));
                                if ($___old_abf21b8e0a8354b3)
                                    ({}.constructor.defineProperty(window, 'XMLHttpRequest', $___mock_a5bc79bcf07d3b62.XMLHttpRequest));
                                return function () {
                                    var uaCommand, gaNamespace = window.GoogleAnalyticsObject, userId = $analyticsProvider.settings.ga.userId;
                                    if (userId && angular.isObject(fieldsObj) && (fieldsObj.userId = userId), command.indexOf('ecommerce:') > -1 && $analyticsProvider.settings.ga.enhancedEcommerce)
                                        switch (command) {
                                        case 'ecommerce:addTransaction':
                                            command = [
                                                'ec:setAction',
                                                'purchase'
                                            ];
                                            break;
                                        case 'ecommerce:addItem':
                                            command = 'ec:addProduct', fieldsObj.id = fieldsObj.sku;
                                            break;
                                        case 'ecommerce:send':
                                            command = 'send', fieldsObj.hitType = 'event', fieldsObj.eventCategory = 'Angulartics Enhanced Ecommerce', fieldsObj.eventAction = 'Purchase', fieldsObj.nonInteraction = !0;
                                        }
                                    'require' === command && 'ecommerce' === fieldsObj && $analyticsProvider.settings.ga.enhancedEcommerce && (fieldsObj = 'ec'), uaCommand = command instanceof Array ? command.concat(fieldsObj) : [
                                        command,
                                        fieldsObj
                                    ], window[gaNamespace].apply(this, uaCommand), shouldCopyHit && (userId && !$analyticsProvider.settings.ga.additionalAccountHitTypes.userId && delete fieldsObj.userId, angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function (accountName) {
                                        var uaCommandClone = [].slice.call(uaCommand);
                                        uaCommandClone[0] = accountName + '.' + uaCommandClone[0], window[gaNamespace].apply(this, uaCommandClone);
                                    }));
                                }.apply(this, arguments);
                            } finally {
                                if ($___old_22dc4d56b12a305e)
                                    ({}.constructor.defineProperty(window, 'XMLHttpRequest', $___old_22dc4d56b12a305e));
                                if ($___old_abf21b8e0a8354b3)
                                    ({}.constructor.defineProperty(window, 'XMLHttpRequest', $___old_abf21b8e0a8354b3));
                            }
                        }
                        function dispatchToClassic_(command, fieldsObj, shouldCopyHit) {
                            if ('set' === command)
                                return console.log('Classic Analytics does not support the "set" command or Custom Dimensions. Command ignored.');
                            var classicCommand;
                            if ('send' === command)
                                switch (fieldsObj.hitType) {
                                case 'pageview':
                                    classicCommand = [
                                        '_trackPageview',
                                        fieldsObj.page
                                    ];
                                    break;
                                case 'event':
                                    classicCommand = [
                                        '_trackEvent',
                                        fieldsObj.category,
                                        fieldsObj.action,
                                        fieldsObj.label,
                                        fieldsObj.value,
                                        fieldsObj.nonInteraction
                                    ];
                                    break;
                                case 'timing':
                                    classicCommand = [
                                        '_trackTiming',
                                        fieldsObj.timingCategory,
                                        fieldsObj.timingVar,
                                        fieldsObj.timingValue,
                                        fieldsObj.timingLabel,
                                        fieldsObj.optSampleRate
                                    ];
                                }
                            return 'ecommerce:addTransaction' === command && (classicCommand = [
                                '_addTrans',
                                fieldsObj.id,
                                fieldsObj.affiliation,
                                fieldsObj.revenue,
                                fieldsObj.tax,
                                fieldsObj.shipping,
                                fieldsObj.billingCity,
                                fieldsObj.billingRegion,
                                fieldsObj.billingCountry
                            ]), 'ecommerce:addItem' === command && (classicCommand = [
                                '_addItem',
                                fieldsObj.id,
                                fieldsObj.sku,
                                fieldsObj.name,
                                fieldsObj.category,
                                fieldsObj.price,
                                fieldsObj.quantity
                            ]), '_set' === command && (classicCommand = [
                                '_set',
                                'currencyCode',
                                fieldsObj
                            ]), 'ecommerce:send' === command && (classicCommand = ['_trackTrans']), classicCommand ? (window._gaq.push(classicCommand), void (shouldCopyHit && angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function (accountName) {
                                var classicCommandClone = [].slice.call(classicCommand);
                                classicCommandClone[0] = accountName + '.' + classicCommandClone[0], window._gaq.push(classicCommandClone);
                            }))) : console.log('Unable to find command ' + command + ' or fieldsObj missing required properties. Command ignored.');
                        }
                        var handler;
                        return detectClassicAnalytics() && (handler = dispatchToClassic_), detectUniversalAnalytics() && (handler = dispatchToUniversal_), handler ? function (method, command, fieldsObj) {
                            var shouldCopyHit = $analyticsProvider.settings.ga.additionalAccountHitTypes[method];
                            handler(command, fieldsObj, shouldCopyHit);
                        } : (console.log('Error: neither Classic nor Universal Analytics detected at bootstrap. Angulartics-GA will ignore all commands!'), angular.noop);
                    }();
                }
            ]);
        }(window, window.angular);
    }())
}